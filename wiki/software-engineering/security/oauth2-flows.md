---
tags: softwareengineering, security, oauth2
---

# Authorization Code with PKCE (Secret)

![[auth-code-flow.png]]

Step-by-step explanation:

1. **Client Registration**:
    - The client (an application) registers with the authorization server and obtains a client ID and a client secret.
    - The client ID is a public identifier, and the client secret is a confidential piece of information known only to the client and the authorization server.
2. **User Initiates Authorization**:
    - A user initiates an action that requires access to protected resources, typically by clicking a "Login with XYZ" button in the client application.
3. **Redirect to Authorization Server**:
    - The client redirects the user's browser to the authorization server's authorization endpoint, along with the following parameters:
        - `response_type=code`: Indicates that the client is requesting an authorization code.
        - `client_id`: The client's public identifier.
        - `redirect_uri`: The URI to which the authorization server will redirect the user after authorization.
        - `scope`: The requested scope of access (e.g., read, write permissions).
        - `state` (optional): A random value generated by the client, which is used to prevent cross-site request forgery (CSRF) attacks.
4. **User Authorizes Access**:
    - The user logs in or provides consent to the authorization server to grant access to the client application.
    - The user is prompted to approve the requested permissions (scope).
5. **Authorization Code Grant**:
    - Upon user approval, the authorization server issues an authorization code and redirects the user's browser back to the specified `redirect_uri` with the authorization code as a query parameter.
6. **Token Request**:
    - The client, with the authorization code, makes a direct, confidential, and secure HTTP POST request to the authorization server's token endpoint.
    - The request includes the following parameters:
        - `grant_type=authorization_code`: Indicates the type of grant being used.
        - `code`: The authorization code obtained in the previous step.
        - `redirect_uri`: The same redirect URI used in the authorization request.
        - `client_id`: The client's public identifier.
        - `client_secret`: The confidential client secret.
7. **Access Token Response**:
    - The authorization server verifies the authorization code, client ID, and client secret.
    - If the verification is successful, the authorization server responds with an access token and optionally a refresh token.
    - The access token represents the user's authorization and can be used to access protected resources.
8. **Accessing Protected Resources**:
    - The client can now use the access token to access the user's protected resources (e.g., API endpoints) on the resource server.

# Implicit Grant Flow

![[implicit-grant-flow.png]]

1. **Client Registration**: The client application (e.g., a JavaScript-based SPA) is registered with the authorization server. During registration, the client receives a client ID, which is a public identifier for the client. Unlike other OAuth 2.0 flows, there is no client secret in the Implicit Grant Flow.
2. **User Initiates Authorization**: A user initiates an action that requires access to protected resources within the client application. This often involves clicking a "Login with XYZ" button.
3. **Redirect to Authorization Server**: The client application redirects the user's browser to the authorization server's authorization endpoint. The URL includes the following query parameters:
    - `response_type=token`: Indicates that the Implicit Grant Flow is being used.
    - `client_id`: The client's public identifier.
    - `redirect_uri`: The URI to which the authorization server will redirect the user after authorization.
    - `scope` (optional): The requested scope of access (e.g., read, write permissions).
    - `state` (optional): A random value generated by the client for CSRF protection.
4. **User Authorizes Access**: The user logs in or provides consent to the authorization server to grant access to the client application. The user may be prompted to approve the requested permissions (scope).
5. **Access Token Response**: Upon user approval, the authorization server issues an access token and directly returns it in the URL fragment (also known as the "hash fragment") of the redirect URI. The URL may look like this: `https://clientapp.com/callback#access_token=XXXXXXXX&token_type=Bearer&expires_in=3600&state=xyz`
6. **Client Application Access**: The client application's JavaScript code running in the user's browser can extract the access token from the URL fragment. This access token can be used to make authorized API requests to the resource server (e.g., a web API) on behalf of the user.
7. **Token Usage**: The client application includes the access token in the authorization header of HTTP requests made to the resource server. The resource server validates the token to ensure that the client is authorized to access the requested resources.

## Implicit Grant Flow vs. Authorization Code Flow with PKCE

**Implicit Grant Flow**:

-   Less secure because it exposes the access token in the browser's URL fragment.
-   Suitable for client applications running in a web browser or mobile apps without a secure server-side component.
-   Access token retrieval is via the URL fragment, requiring client-side extraction.
-   Does not use an authorization code; issues the access token directly.
-   Used when simplicity is favored over security.

**Authorization Code Flow with PKCE**:

-   More secure as it doesn't expose the access token in the URL fragment.
-   Suitable for various client types, including web browsers, mobile apps, and server-side applications.
-   Access token retrieval is on the server-side using a confidential client secret or PKCE.
-   Involves the use of an authorization code, which is exchanged for the access token.
-   Recommended for scenarios prioritizing security and broader client compatibility.

# Client Credentials Grant Flow

![[client-credential-grant-flow.png]]

1. **Client Registration**: The client application, which is often a server-side application or a service, is registered with the authorization server. During registration, the client receives a client ID and a client secret.
2. **Access Token Request**: The client application sends an HTTP POST request to the authorization server's token endpoint to request an access token. The request includes the following parameters:
    - `grant_type=client_credentials`: Indicates that the Client Credentials Grant Flow is being used.
    - `client_id`: The client's public identifier.
    - `client_secret`: The confidential client secret.
3. **Access Token Response**: The authorization server verifies the client's credentials (client ID and client secret) and, if valid, issues an access token directly to the client application. The access token represents the client's authorization to access protected resources.
4. **Accessing Protected Resources**: With the obtained access token, the client application can now make authorized API requests to the resource server (e.g., an API endpoint). It includes the access token in the authorization header of the HTTP request.
5. **Resource Server Validation**: The resource server validates the access token to ensure that it is valid and that the client is authorized to access the requested resources. If the token is valid, the resource server serves the requested data.

Key Points:

-   The Client Credentials Grant Flow does not involve user authentication. It is typically used for machine-to-machine communication or for services where there is no user interaction.
-   Security relies on the confidentiality of the client secret. Therefore, it is crucial to store the client secret securely on the client application's server.
-   Access tokens obtained in this flow often have limited scopes and shorter lifetimes since there is no user context.
-   It is suitable for scenarios where a client application needs to access its resources on a protected server.
-   This flow is less common for user-oriented applications but is widely used for service-to-service communication, especially in microservices architectures.

In summary, the Client Credentials Grant Flow is used by trusted, confidential client applications to obtain access tokens directly from the authorization server without involving user authentication. It is ideal for server-to-server communication or services where user interaction is not required.

# JWT Bearer Flow

![[jwt-bearer-flow.png]]

1. **Client Registration**: The client application is registered with the authorization server, and the client receives a client ID.
2. **JWT Assertion Creation**: The client constructs a JWT assertion that includes the following information:
    - `iss` (Issuer): The client's identifier, which is typically the client's client ID.
    - `sub` (Subject): The subject of the JWT, which is also often the client's client ID.
    - `aud` (Audience): The audience, which is the authorization server's token endpoint URL.
    - `exp` (Expiration Time): The expiration time of the JWT.
    - Optionally, you can include a `scope` claim to specify the requested scope of access.
3. **JWT Assertion Signing**: The client signs the JWT assertion with its private key (if using asymmetric cryptography) or a shared secret (if using symmetric cryptography). The method of signing depends on the client and authorization server's configuration.
4. **Access Token Request**: The client sends an HTTP POST request to the authorization server's token endpoint, including the JWT assertion as a Bearer token in the request headers. The request typically includes the following parameters:
    - `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer`: Indicates that the JWT Bearer Flow is being used.
    - `assertion`: The JWT assertion itself.
5. **Authorization Server Validation**: The authorization server receives the request, validates the JWT assertion's signature, expiration time, and other claims. If the JWT assertion is valid, the authorization server issues an access token.
6. **Access Token Response**: The authorization server responds with an access token. The format of the access token may vary depending on the authorization server's configuration. It could be a JWT or a standard OAuth 2.0 access token.
7. **Accessing Protected Resources**: With the obtained access token, the client can make authorized API requests to protected resources on the resource server (e.g., API endpoints). The client includes the access token in the authorization header of the HTTP request.
8. **Resource Server Validation**: The resource server validates the access token to ensure that it is valid, not expired, and that the client is authorized to access the requested resources. If the token is valid, the resource server serves the requested data.

The JWT Bearer Flow is particularly useful for client applications, including SPAs, that need to authenticate themselves to obtain access tokens for accessing protected resources. It leverages JWTs for authentication and allows for flexible configurations depending on the client's security requirements and the authorization server's capabilities. It's a secure and versatile way for clients to obtain access tokens without exposing a client secret.

# Refresh Token Flow

![[refresh-token-flow.png]]

1. **Initial Authentication**: The user initially authenticates with the authorization server and grants the client application permission to access their resources. During this authentication, both an access token and a refresh token are typically issued.
2. **Access Token Expiration**: Access tokens have a limited lifespan (typically short-lived, e.g., 15 minutes to 1 hour) to enhance security. As the access token's expiration time approaches, the client application realizes it needs a new token to continue accessing protected resources.
3. **Access Token Request**: The client application sends a request to the authorization server's token endpoint, including the following parameters:
    - `grant_type=refresh_token`: Indicates that the Refresh Token Flow is being used.
    - `refresh_token`: The refresh token obtained during the initial authentication.
    - `client_id`: The client's identifier.
    - Optionally, other parameters like `scope` (if requesting additional permissions).
4. **Authorization Server Validation**: The authorization server receives the request and validates the refresh token, ensuring that it's still valid, hasn't expired, and is associated with the client making the request.
5. **Access Token Refresh**: If the refresh token is valid, the authorization server issues a new access token, and optionally, a new refresh token. The new access token typically has a new expiration time.
6. **Accessing Protected Resources**: The client can now use the new access token to make authorized API requests to the protected resources, just like it did with the initial access token.
7. **Refresh Token Rotation (Optional)**: Some authorization servers implement refresh token rotation, where the old refresh token becomes invalid after use. In such cases, the client receives a new refresh token along with the new access token. This enhances security by preventing long-term use of the same refresh token.

Key Points:

-   The Refresh Token Flow allows for the automatic renewal of access tokens without requiring the user to re-enter their credentials. It reduces the frequency of user logins and improves the user experience.
-   Refresh tokens typically have a longer lifespan compared to access tokens, and they are used to obtain new access tokens when needed.
-   The client must securely store the refresh token because it can be used to obtain new access tokens. Loss or compromise of a refresh token can have security implications.
-   The authorization server validates the refresh token and may perform additional checks to ensure the client is still authorized.
-   The exact mechanics and token expiration times can vary depending on the authorization server's configuration and policies.

# Summary of all Flows

1. **Authorization Code Flow**:
    - **Purpose**: Used for server-side applications and web apps that can protect a client secret.
    - **Access Token Retrieval**: Involves an authorization code exchange on the server side.
    - **Security**: More secure due to code exchange and ability to protect client secrets.
    - **User Interaction**: Requires user interaction for initial login and authorization.
2. **Implicit Grant Flow**:
    - **Purpose**: Suited for client-side applications (e.g., SPAs) and mobile apps without a client secret.
    - **Access Token Retrieval**: Access token is directly returned in the browser's URL fragment.
    - **Security**: Less secure due to token exposure in the URL fragment.
    - **User Interaction**: Requires user interaction for initial login and authorization.
3. **Client Credentials Grant Flow**:
    - **Purpose**: Used by confidential or trusted clients for machine-to-machine communication.
    - **Access Token Retrieval**: Directly requests access token with client credentials.
    - **Security**: Security relies on the client's ability to protect its credentials.
    - **User Interaction**: No user interaction; client-to-server authorization.
4. **JWT Bearer Flow (Client Assertion Flow)**:
    - **Purpose**: Allows clients to obtain access tokens using self-contained JWT assertions.
    - **Access Token Retrieval**: Uses a signed JWT assertion for authentication.
    - **Security**: Secure, as long as the JWT is properly signed and validated.
    - **User Interaction**: No user interaction; client-to-server authorization. Can optionally include user-related information in the JWT.
5. **Refresh Token Flow**:
    - **Purpose**: Allows clients to obtain new access tokens without user interaction.
    - **Access Token Retrieval**: Uses a previously obtained refresh token to get a new access token.
    - **Security**: Secure, as long as the refresh token is kept confidential.
    - **User Interaction**: Reduces the need for frequent user logins.
